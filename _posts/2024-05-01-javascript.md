---
layout: post
title: 'JavaScript'
tags: ['javascript']
date: 2024-04-30 11:50:00
---

웹을 개발할 때 자바스크립트는 필수적으로 만나게 되는 언어입니다. 하지만, 자바스크립트가 주력 언어가 아니기에 소홀히 했고, 헷갈리는 문법이나 개념을 필요할 때마다 찾아보고 프로그래밍 해왔습니다. 그러다 보니 자바스크립트의 개념들이 파편적으로 흩어져 더욱 저를 혼란스럽게 만드는 느낌입니다. 그래서 이번 포스트에선 자바스크립트에 대해 헷갈리는 키워드를 정리하고자 합니다.

<br>
<br>

### **Var과 Let 그리고 const**

---

var은 함수 범위(Function scope)이고 Let은 블록 범위(Block scope)를 가집니다. 그래서 var의 경우 같은 함수 안에 있는 변수는 공유하게 되며, 예상치 못한 값이 변수에 들어갈 우려가 있습니다.(golang에서 캡쳐 기능과 유사)

그리고, var 변수로 전역 변수를 설정하게 되면, window객체의 속성에 들어가게 됩니다. 또한, 중복 선언과 선언문 이전 접근이 가능합니다.

const는 let과 마찬가지로 블록 범위를 가지고, 중복 선언이 불가능합니다. 차이점은 const는 상수 선언이라는 점입니다.(하지만 객체의 속성은 변경이 가능하고 객체의 속성도 상수로 만들고 싶다면 Object.freeze함수를 사용)

<br>
<br>

### **this 와 함수, this와 에로우 함수**

---

this는 현재 실행 중인 함수의 컨텍스트(객체)를 가리킵니다. 그리고, 객체에서 this는 해당 객체를 가리킵니다.

함수에서 사용되는 this의 경우, this는 함수를 호출한 객체에 바인딩(런타임 바인딩) 됩니다. 예를 들어, 함수a가 있다고 하면 object1.a 에서의 this는 obect1를 가리키고, object2.a 에서의 this는 object2를 가리킵니다.(object1과 object2는 a 함수를 대입받은 메서드 a가 존재합니다.) 하지만 callback 함수로써 함수a를 대입받고 callback함수를 실행시키면, 해당 콜백 함수 단독으로만 쓰이게 되어 전역 객체에 바인딩 되게 됩니다. 이러한 런타임 바인딩을 통제하려면 bind함수를 통해 해당 함수의 this를 고정적인 객체와 바인딩 시키면 됩니다.

그리고, 위에서 설명한 bind 과정을 통해 고정적인 객체와 바인딩하는 함수가 에로우 함수입니다. 에로우 함수는 호출 시점에서의 상위 영역의 this와 자동적으로 bind 하게 됩니다. 이때, 바인딩 우선 순위는 에로우 함수가 bind를 사용하는 방법보다 높습니다.

추가적으로, 전역 객체의 메서드에서 (a 함수 또는 object.a 메서드를 대입한)콜백 함수를 호출하는 경우, 콜백 함수는 호출 객체 또는 바인드에 따라 this가 정해져 있을 수 있습니다. 하지만, 에로우 함수를 콜백 함수로 사용할 경우 해당 상위 스코프에서 this를 가져옵니다.(우선순위가 높기 때문)

<br>
<br>

### **콜백 지옥과 Promise와 Async&Await**

---

콜백 함수는 다른 함수의 인자로 전달 되는 함수를 말합니다. 주로 콜백 함수는 비동기 작업과 함께 쓰입니다. 비동기 함수가 끝나고 후처리를 하기 위해 비동기 콜백 함수를 사용합니다. 이때, 여러 비동기 작업을 순서대로 처리하는 코드를 작성할 때, 콜백 지옥에 빠지기 쉽습니다. 이러한 콜백 지옥은 코드를 읽기 어렵게 만들고 유지 보수하기 어렵게 만드는 단점이 있습니다.

프로미스는 비동기 처리에 사용되는 자바스크립트 객체입니다. 그리고 이 객체는 state와 result를 가집니다. state는 3가지 상태를 가집니다. pending, fulfiled, rejected 각각의 상태는 작업 중, 성공, 실패를 나타냅니다. 그리고 해당 상태에 따라 undefined, 결과값, error를 result로 가집니다.(프로미스는 생성되는 순간 실행됩니다.)
then 함수는 프로미스가 fulfiled 된 이후에 실행하는 콜백 함수를 실행시킵니다. 해당 콜백 함수는 프로미스에서 전달한 result 결과값을 인자로 받을 수 있습니다.
catch 함수는 프로미스가 rejected 된 이후 실행하는 콜백 함수로 마찬가지로 프로미스에서 정의한 결과값을 인자로 받을 수 있습니다.
마지막으로, finally 함수는 프로미스 작업이 성공하든 실패하든 실행됩니다.

이러한 프로미스의 then, catch메서드 안에서 return 을 통해 새로운 프로미스를 전달(문자열을 리턴해도 해당 문자열을 프로미스로 감쌉니다)하면 그 다음 비동기 작업을 진행할 수 있습니다. 이러한 방식을 프로미스 체이닝이라고 합니다. 이를 통해 콜백 지옥을 해결할 수 있습니다.

프로미스 static 메서드에는 Promise.all, Promise.allSettled가 있습니다. Promiss.all의 경우 프로미스가 하나라도 reject된다면 reject를 반환합니다. 반면 allSettled의 경우에는 모든 프로미스가 완료된 이후에 반환하고, 각 프로미스의 상태(결과)를 알 수 있습니다.

Async와 Await을 사용하면 프로미스 체이닝 방식이 아닌 더 간결한 코드를 작성할 수 있습니다. Async은 함수 앞에 붙는 키워드로 해당 함수를 비동기 함수로 만들고, 결과값을 프로미스 객체로 만듭니다. 그리고 await 키워드는 비동기 함수들을 순차적으로 작업할 수 있습니다.
